<head>
    <meta charset="UTF-8">
    <title>Excerise 10 - Technical Documentation Page</title>
    <meta name="author" content="Đenan Cigura">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link type="text/css" rel="stylesheet" href="./index.css">
    <script src="https://kit.fontawesome.com/a076d05399.js"></script>
</head>

<body>
    <nav id="navbar">
        <!--User Story #11-->
        <header>
            <p>Eloquent JavaScript</p>
        </header>
        <ul>
            <li><a class="nav-links" href="#introduction">Introduction</a></li>
            <li><a class="nav-links" href="#values_types_and_operators">Values, Types and Operators</a></li>
            <li><a class="nav-links" href="#program_structure">Program structure</a></li>
            <li><a class="nav-links" href="#functions">Functions</a></li>
            <li><a class="nav-links" href="#objects_and_arrays">Data Structures</a></li>
            <li><a class="nav-links" href="#higher_order_functions">Higher-order Functions</a></li>
            <li><img id="header-img" src="https://eloquentjavascript.net/img/cover.jpg" alt="Eloquent JavaScript">  </li>
        </ul>
    </nav>

    <main id="main-doc">
        <section class="main-section" id="introduction">
            <header><h1>Introduction</h1></header>
            <article>
                <h4><q>Below the surface of the machine, the program moves. Without effort, it expands and contracts. In
                        great harmony, electrons scatter and regroup. The forms on the monitor are but ripples on the
                        water. The essence stays invisibly below.</q>
                    Master Yuan-Ma, The Book of Programming</h4>
                <p>Inside the computer’s world, there is only data. You can read data, modify data, create new data—but
                    that which isn’t data cannot be mentioned. All this data is stored as long sequences of bits and is
                    thus fundamentally alike.</p>
                <ul>
                    <li>Bits are any kind of <strong>two-valued </strong>things, usually described as zeros and ones. Inside the computer,
                        they take forms such as a high or low electrical charge, a strong or weak signal, or a shiny or dull
                        spot on the surface of a CD. Any piece of discrete information can be reduced to a sequence of zeros
                        and ones and thus represented in bits.</li>
                    <li>For example, we can express the number 13 in bits. It works the same way as a decimal number, but
                        instead of 10 different digits, you have only 2, and the weight of each increases by a factor of 2
                        from right to left. Here are the bits that make up the number 13, with the weights of the digits
                        shown below them:</li>
                        <code>
                                <pre>
                        0   0   0   0   1   1   0   1
                        128  64  32  16   8   4   2   1
                                </pre>
                        </code>
                </ul>
            </article>
        </section>
        <section class="main-section" id="values_types_and_operators">
            <header><h1>Values, Types, and Operators</h1></header>
            <article>
                <p>Imagine a sea of bits—an ocean of them. A typical modern computer has more than 30 billion bits in
                    its volatile data storage (working memory). Nonvolatile storage (the hard disk or equivalent) tends
                    to have yet a few orders of magnitude more.</p>
                <p>To be able to work with such quantities of bits without getting lost, we must separate them into
                    chunks that represent pieces of information. In a JavaScript environment, those chunks are called
                    values. Though all values are made of bits, they play different roles. Every value has a type that
                    determines its role. Some values are numbers, some values are pieces of text, some values are
                    functions, and so on.</p>
                
                <p>This chapter introduces the atomic elements of JavaScript programs, that is, the simple value types
                    and the operators that can act on such values.</p>
                
                <code>
                <pre>     
                0   0   0   0   1   1   0   1
                128  64  32  16   8   4   2   1
                </pre>
                </code>
            </article>
        </section>
        <section class="main-section" id="program_structure">
            <header>Program structure</header>
            <article>
                <p>Values of the number type are, unsurprisingly, numeric values. In a JavaScript program, they are
                    written as follows:</p>
                <code>13</code>
                <p>Use that in a program, and it will cause the bit pattern for the number 13 to come into existence
                    inside the computer’s memory.</p>
                <p>value. There are only so many patterns you can make with 64 bits, which means that the number of
                    different numbers that can be represented is limited. With N decimal digits, you can represent 10N
                    numbers. Similarly, given 64 binary digits, you can represent 264 different numbers, which is about
                    18 quintillion (an 18 with 18 zeros after it). That’s a lot.</p>
                <p>Computer memory used to be much smaller, and people tended to use groups of 8 or 16 bits to represent
                    their numbers. It was easy to accidentally overflow such small numbers—to end up with a number that
                    did not fit into the given number of bits. Today, even computers that fit in your pocket have plenty
                    of memory, so you are free to use 64-bit chunks, and you need to worry about overflow only when
                    dealing with truly astronomical numbers.</p>
                <p>Not all whole numbers less than 18 quintillion fit in a JavaScript number, though. Those bits also
                    store negative numbers, so one bit indicates the sign of the number. A bigger issue is that nonwhole
                    numbers must also be represented. To do this, some of the bits are used to store the position of the
                    decimal point. The actual maximum whole number that can be stored is more in the range of 9
                    quadrillion (15 zeros)—which is still pleasantly huge.</p>
                <p>Fractional numbers are written by using a dot.</p>
                <code>9.81</code>
                <p>For very big or very small numbers, you may also use scientific notation by adding an e (for
                    exponent), followed by the exponent of the number.</p>
                <code>2.998e8</code>
                <code>That is 2.998 × 108 = 299,800,000.</code>
                <p>Calculations with whole numbers (also called integers) smaller than the aforementioned 9 quadrillion
                    are guaranteed to always be precise. Unfortunately, calculations with fractional numbers are
                    generally not. Just as π (pi) cannot be precisely expressed by a finite number of decimal digits,
                    many numbers lose some precision when only 64 bits are available to store them. This is a shame, but
                    it causes practical problems only in specific situations. The important thing is to be aware of it
                    and treat fractional digital numbers as approximations, not as precise values.</p>
            </article>
        </section>
        <section class="main-section" id="functions">
            <header>Functions </header>
            <article>
                <p>The main thing to do with numbers is arithmetic. Arithmetic operations such as addition or
                    multiplication take two number values and produce a new number from them. Here is what they look
                    like in JavaScript:</p>
                <code>100 + 4 * 11</code>
                <p>The + and * symbols are called operators. The first stands for addition, and the second stands for
                    multiplication. Putting an operator between two values will apply it to those values and produce a
                    new value.</p>
                <p>But does the example mean “add 4 and 100, and multiply the result by 11,” or is the multiplication
                    done before the adding? As you might have guessed, the multiplication happens first. But as in
                    mathematics, you can change this by wrapping the addition in parentheses.</p>
                <code>(100 + 4) * 11</code>
                <p>For subtraction, there is the - operator, and division can be done with the / operator.</p>
                <p>When operators appear together without parentheses, the order in which they are applied is determined
                    by the precedence of the operators. The example shows that multiplication comes before addition. The
                    / operator has the same precedence as *. Likewise for + and -. When multiple operators with the same
                    precedence appear next to each other, as in 1 - 2 + 1, they are applied left to right: (1 - 2) + 1.
                </p>
                <p>These rules of precedence are not something you should worry about. When in doubt, just add
                    parentheses.</p>
                <p>recognize. The % symbol is used to represent the remainder operation. X % Y is the remainder of
                    dividing X by Y. For example, 314 % 100 produces 14, and 144 % 12 gives 0. The remainder operator’s
                    precedence is the same as that of multiplication and division. You’ll also often see this operator
                    referred to as modulo.</p>
            </article>
        </section>
        <section class="main-section" id="objects_and_arrays">
            <header>Data Stustures: Objects and Arrays</header>
            <article>
                <p>There are three special values in JavaScript that are considered numbers but don’t behave like normal
                    numbers.</p>
                <p>The first two are <code>Infinity</code> and <code>-Infinity</code>, which represent the positive and
                    negative infinities. Infinity - 1 is still Infinity, and so on. Don’t put too much trust in
                    infinity-based computation, though. It isn’t mathematically sound, and it will quickly lead to the
                    next special number: <code>NaN</code> .</p>
                <p><code>NaN</code> stands for “not a number”, even though it is a value of the number type. You’ll get
                    this result when you, for example, try to calculate <code>0 / 0</code> (zero divided by zero),
                    Infinity - Infinity, or any number of other numeric operations that don’t yield a meaningful result.
                </p>
            </article>
        </section>
        <section class="main-section" id="higher_order_functions">
            <header>Higher-order Functions</header>
            <article>
                <p>The next basic data type is the string. Strings are used to represent text. They are written by
                    enclosing their content in quotes.</p>
                <code>`Down on the sea`<br>
                        "Lie on the ocean" <br>  
                        'Float on the ocean'</code>
                <p>You can use single quotes, double quotes, or backticks to mark strings, as long as the quotes at the
                    start and the end of the string match.</p>
                <p>Almost anything can be put between quotes, and JavaScript will make a string value out of it. But a
                    few characters are more difficult. You can imagine how putting quotes between quotes might be hard.
                    Newlines (the characters you get when you press enter) can be included without escaping only when
                    the string is quoted with backticks (`).</p>
                <p>To make it possible to include such characters in a string, the following notation is used: whenever
                    a backslash (\) is found inside quoted text, it indicates that the character after it has a special
                    meaning. This is called escaping the character. A quote that is preceded by a backslash will not end
                    the string but be part of it. When an n character occurs after a backslash, it is interpreted as a
                    newline. Similarly, a t after a backslash means a tab character. Take the following string:</p>
                <code>"This is the first line\nAnd this is the second"</code>
                <p>The actual text contained is this:</p>
                <code>This is the first line <br>
                        And this is the second</code>
                <p>There are, of course, situations where you want a backslash in a string to be just a backslash, not a
                    special code. If two backslashes follow each other, they will collapse together, and only one will
                    be left in the resulting string value. This is how the string “A newline character is written like
                    "\n".” can be expressed:</p>
                <code>"A newline character is written like \"\\n\"."</code>
                <p>Strings, too, have to be modeled as a series of bits to be able to exist inside the computer. The way
                    JavaScript does this is based on the Unicode standard. This standard assigns a number to virtually
                    every character you would ever need, including characters from Greek, Arabic, Japanese, Armenian,
                    and so on. If we have a number for every character, a string can be described by a sequence of
                    numbers.
                </p>
                <p>And that’s what JavaScript does. But there’s a complication: JavaScript’s representation uses 16 bits
                    per string element, which can describe up to 216 different characters. But Unicode defines more
                    characters than that—about twice as many, at this point. So some characters, such as many emoji,
                    take up two “character positions” in JavaScript strings. We’ll come back to this in Chapter 5.</p>
                <p>Strings cannot be divided, multiplied, or subtracted, but the + operator can be used on them. It does
                    not add, but it concatenates—it glues two strings together. The following line will produce the
                    string <code>"concatenate"</code>:</p>
                <code>"con" + "cat" + "e" + "nate"</code>
                <p>String values have a number of associated functions (methods) that can be used to perform other
                    operations on them. I’ll say more about these in Chapter 4.</p>
                <p>Strings written with single or double quotes behave very much the same—the only difference is in
                    which type of quote you need to escape inside of them. Backtick-quoted strings, usually called
                    template literals, can do a few more tricks. Apart from being able to span lines, they can also
                    embed other values.</p>
                <code>`half of 100 is ${100 / 2}`</code>
                <p>When you write something inside <code>${}</code> in a template literal, its result will be computed,
                    converted to a string, and included at that position. The example produces
                    <code>“half of 100 is 50”</code> .</p>
            </article>
        </section>
       <section class="main-section" id="boolean_values">
            <header>Boolean values</header>
            <article>
                <p>It is often useful to have a value that distinguishes between only two possibilities, like “yes” and
                    “no” or “on” and “off”. For this purpose, JavaScript has a Boolean type, which has just two values,
                    true and false, which are written as those words.</p>
                    <ul>
                        <li><code>console.log(typeof 4.5)</code></li>
                        <li><code>// → number</code></li>
                        <li><code>console.log(typeof "x")</code></li>
                        <li><code>// → string</code></li>
                    </ul>
                <p>We will use <code>console.log</code> in example code to indicate that we want to see the result of
                    evaluating something. More about that in the next chapter.</p>
                <p>The other operators shown all operated on two values, but typeof takes only one. Operators that use
                    two values are called binary operators, while those that take one are called unary operators. The
                    minus operator can be used both as a binary operator and as a unary operator.</p>
                    <ul>
                        <li><code>console.log(- (10 - 2))</code></li>
                        <li><code>// → -8</code></li>
                    </ul>
                    <h3>Comparison</h3>
                    <p>Here is one way to produce Boolean values:</p>
                    <ul>
                        <li><code>console.log(3 > 2)</code></li>
                        <li><code>// → true</code></li>
                        <li><code>console.log(3 < 2)</code></li>
                        <li><code>// → false</code></li>
                    </ul>
                    <p>The > and < signs are the traditional symbols for “is greater than” and “is less than”, respectively. They are binary operators. Applying them results in a Boolean value that indicates whether they hold true in this case.</p>
                    <p>Strings can be compared in the same way.</p>
                    <ul>
                        <li><code>console.log("Aardvark" < "Zoroaster")</code></li>
                        <li><code>// → true</code></li>
                    </ul>
                    <p>The way strings are ordered is roughly alphabetic but not really what you’d expect to see in a dictionary: uppercase letters are always “less” than lowercase ones, so "Z" < "a", and nonalphabetic characters (!, -, and so on) are also included in the ordering. When comparing strings, JavaScript goes over the characters from left to right, comparing the Unicode codes one by one.</p>
                    <p>Other similar operators are >= (greater than or equal to), <= (less than or equal to), == (equal to), and != (not equal to).</p>
                    <ul>
                        <li><code>console.log("Itchy" != "Scratchy")</code></li>
                        <li><code>// → true</code></li>
                        <li><code>console.log("Apple" == "Orange")</code></li>
                        <li><code>// → false</code></li>
                    </ul>

            </article>
        </section>
    </main>
</body>